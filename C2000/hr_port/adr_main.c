//###########################################################################
// Description:
//! \addtogroup f2806x_example_list
//! <h1>ePWM Timer Interrupt From Flash (flash_f28069)</h1>
//!
//! This example runs the ePWM interrupt example from flash. ePwm1 Interrupt 
//! will run from RAM and puts the flash into sleep mode. ePwm2 Interrupt 
//! will run from RAM and puts the flash into standby mode. ePWM3 Interrupt
//! will run from FLASH. All timers have the same period. The timers are 
//! started sync'ed. An interrupt is taken on a zero event for each ePWM 
//! timer.GPIO34 is toggled while in the background loop.
//! Note:
//!   - ePWM1: takes an interrupt every event
//!   - ePWM2: takes an interrupt every 2nd event
//!   - ePWM3: takes an interrupt every 3rd event 
//! Thus the Interrupt count for ePWM1, ePWM4-ePWM6 should be equal
//! The interrupt count for ePWM2 should be about half that of ePWM1
//! and the interrupt count for ePWM3 should be about 1/3 that of ePWM1
//! 
//! Follow these steps to run the program.
//!   - Build the project
//!   - Flash the .out file into the device.
//!   - Set the hardware jumpers to boot to Flash (put position 1 and 2 of 
//!     SW2 on control Card to ON position).
//!   - Use the included GEL file to load the project, symbols
//!     defined within the project and the variables into the watch
//!     window.
//! 
//! Steps that were taken to convert the ePWM example from RAM
//! to Flash execution: 
//! - Change the linker cmd file to reflect the flash memory map.
//! - Make sure any initialized sections are mapped to Flash.
//!   In SDFlash utility this can be checked by the View->Coff/Hex
//!   status utility. Any section marked as "load" should be
//!   allocated to Flash.
//! - Make sure there is a branch instruction from the entry to Flash
//!   at 0x3F7FF6 to the beginning of code execution. This example
//!   uses the DSP0x_CodeStartBranch.asm file to accomplish this.
//! - Set boot mode Jumpers to "boot to Flash"
//! - For best performance from the flash, modify the waitstates
//!   and enable the flash pipeline as shown in this example.
//!   Note: any code that manipulates the flash waitstate and pipeline
//!   control must be run from RAM. Thus these functions are located
//!   in their own memory section called ramfuncs.
//! 
//! \b Watch \b Variables \n
//!  - EPwm1TimerIntCount
//!  - EPwm2TimerIntCount
//!  - EPwm3TimerIntCount
//
//###########################################################################
// $TI Release: F2806x C/C++ Header Files and Peripheral Examples V135 $
// $Release Date: Sep 8, 2012 $
//###########################################################################

#include "DSP28x_Project.h"     // Device Headerfile and Examples Include File
#include "string.h"

#include "HR_C_Port/heart_rate_official_cport.h"
#include "HR_C_Port/plus.h"
#include <stdint.h>
#include "leads_off_detection.h"



// Make this long enough so that we can see an LED toggle
#define DELAY 1000000L

#define PWM1_TIMER_TBPRD   18750 // Helps determine the PWM Freq. (helps only, doesn't entirely determin the freq)
#define slave_address 0x48

#define header_byte 42 // TODO: Needs work

char shifts[] = {24, 16, 8};
char current_shift_index = 0;

// Functions that will be run from RAM need to be assigned to
// a different section.  This section will then be mapped using
// the linker cmd file.
#pragma CODE_SECTION(epwm1_timer_isr, "ramfuncs");
#pragma CODE_SECTION(adc_isr, "ramfuncs");
#pragma CODE_SECTION(InitFlash, "ramfuncs");
#pragma CODE_SECTION(i2c_int1, "ramfuncs");

// Prototype statements for functions found within this file.
interrupt void epwm1_timer_isr(void);
interrupt void adc_isr(void);
interrupt void i2c_int1(void);
void InitEPwmTimer(void);
void init_adc(void);

// Global variables used in this example
Uint32  EPwm1TimerIntCount;
Uint32  LoopCount;
uint32_t isr_counter = 0;
uint16_t ConversionCount = 0;
Uint16 IntSource = 0;

uint16_t num_rec_slave_addr = 0; // Number of times i2c module has recognized it's own slave address(or 0x00 -- general call) on the bus
uint16_t num_bytes_moved_to_tx_shift = 0; // Number of bytes that have moved to the transmit shift register from the data transmit register (as counted by XRDY interrupt)


int adc_0 = 0; // These are where we will store the values of the ADC conversion
int adc_1 = 0; // They are signed ints instead of unsigned ints because we are going to need to subtract them later

// These are defined by the linker (see F2808.cmd)
extern Uint16 RamfuncsLoadStart;
extern Uint16 RamfuncsLoadEnd;
extern Uint16 RamfuncsRunStart;
extern Uint16 RamfuncsLoadSize;


// Number of HR results we average over
#define NUM_HRS_AVG  6
#define NUM_HRS_AVG_FI NUM_HRS_AVG * 1024 // Equal to 4 In Fixed point:
/**
 * Linked buffer definitions
 */
// The length of data in seconds used for estimating HR
#define SAMPLE_TIME 5
// The length of new data in seconds that is averaged w/ old data to find HR
#define NEW_DATA_SAMPLE_TIME 1
// Sampling rate
#define FS 100
#define BUFFER_SIZE NEW_DATA_SAMPLE_TIME * FS
#define CEIL(VARIABLE) ( (VARIABLE - (int)VARIABLE)==0 ? (int)VARIABLE : (int)VARIABLE+1 )
#define NUM_BUFFERS CEIL(SAMPLE_TIME/NEW_DATA_SAMPLE_TIME)
// How many sample sizes before we reset the hr delta avg
#define RESET_THRESH 10
/**
 * Defines the PCB struct
 */
struct linked_buffer {
	int32_T buffer[BUFFER_SIZE]; // Each buffer is the number of samples in a new data sample
    struct linked_buffer *next; /* Next buffer in the list */
};
typedef struct linked_buffer Linked_Buffer;

Linked_Buffer *linked_buffer_head, *linked_buffer_tail;

// Buffers for processing data
#pragma SET_DATA_SECTION(".big_stuff")

Linked_Buffer circular_buffers[NUM_BUFFERS];

#pragma SET_DATA_SECTION()

Linked_Buffer *current_linked_buffer;
//unsigned int data_out[SAMPLE_TIME * FS];
unsigned int num_empty_buffers_left = NUM_BUFFERS, buffers_full = 0, current_index = 0;
/**
 * Heart Rate Algorithm parameters
 */
//long threshold_1 = 153; // .15
long threshold_1 = 184; // .18
//long threshold_1 = 112; // .11
//long threshold_1 = 122; //.12
long threshold_2 = 307;
long threshold_3 = 204;
long pos_deviance = 5120; // 5
//long pos_deviance = 10240; // 10
long neg_deviance = 665; // .65
//long neg_deviance = 686; // .67
//long neg_deviance = 716; // .7
//long neg_deviance = 512; // .5
//long neg_deviance = 768; //.75
uint32_T sample_time = 5;
uint32_T should_output = 0;
int32_T prev_hr_delta = 0;
int32_T hr_delta_sum = 0;
//int32_T toss_thresh = 5120; // 5
int32_T toss_thresh = 7168; // 7
int32_T num_peak_deltas = 0;
//int32_T neg_peak_deviance_threshold = 266; // .25
//int32_T neg_peak_deviance_threshold = 307; // .3
//int32_T neg_peak_deviance_threshold = 358; // .35
//int32_T neg_peak_deviance_threshold = 409; // .35
int32_T neg_peak_deviance_threshold = 102400; // 100 - Essentially disables noise filtering based on peak delta dev.

unsigned int hr_index = 0, num_hrs = 0, reset_counter = 0;
/**
 * Heart Rate Output variables
 */
// Holds the HRs
int32_T heart_rates[NUM_HRS_AVG];
int32_T heart_rate_avg;
int32_T heart_rate = 0;
unsigned int calculating = 0, copying = 0;
/**
 * Linked list function prototypes
 */
static void copyDataOut(Linked_Buffer *head, int32_T *buf);
static void addData(int32_T val);
static void initLinkedBuffers();
static void runHRAlgo();






#pragma SET_DATA_SECTION(".big_stuff")
// Baby 142bpm
//int32_T Voltages[500]={93,205,-50,-165,18,1,-29,4,-6,3,6,10,24,30,29,36,43,47,41,32,21,-5,-14,-19,-27,-28,-29,-27,-25,-22,-8,-11,-19,-4,3,-10,-18,-10,-10,-23,-25,-16,-16,74,232,28,-187,-5,30,-28,20,16,11,20,24,32,39,46,49,41,45,51,44,29,-5,-28,-24,-25,-34,-34,-30,-29,-31,-34,-27,-22,-27,-28,-28,-35,-36,-25,-6,-19,-37,-41,79,232,-24,-188,27,29,-23,10,-14,-13,3,9,15,16,11,21,34,39,36,22,7,-16,-37,-45,-47,-48,-53,-51,-41,-39,-34,-23,-16,-11,-4,3,-7,-16,-19,-7,6,-4,-33,29,215,63,-182,-14,50,-22,1,-12,-8,5,12,29,29,21,30,41,45,45,45,32,4,-19,-28,-30,-36,-35,-23,-23,-23,-16,-5,15,11,-1,-7,-19,-28,-31,-33,-25,-23,-28,-37,0,178,102,-195,-75,63,-31,-25,-13,-22,-1,18,18,12,29,46,43,32,34,45,39,3,-23,-29,-29,-28,-28,-36,-46,-34,-23,-27,-23,-11,-8,-18,-19,-19,-30,-19,-12,-25,-25,-18,-22,101,224,-36,-176,22,23,-16,13,4,12,17,32,51,49,34,28,38,50,50,41,29,6,-19,-33,-37,-37,-30,-16,-22,-40,-34,-22,-19,0,5,-10,-28,-39,-30,-19,-20,-20,-20,66,228,38,-195,-19,39,-20,12,4,7,10,13,39,44,30,36,50,47,51,44,18,1,-10,-18,-28,-45,-50,-36,-33,-36,-27,-13,-8,-8,-1,-4,-12,-10,-14,-19,-16,-13,-18,-33,22,220,109,-179,-46,51,-18,5,-10,-7,7,9,15,29,43,40,36,44,56,47,28,10,-8,-24,-40,-47,-39,-29,-31,-34,-35,-37,-24,-17,-20,-13,-14,-29,-34,-24,-20,-28,-24,-28,50,212,32,-176,-2,39,-22,11,10,12,13,13,21,29,36,41,43,39,35,30,21,5,-13,-29,-40,-37,-28,-22,-18,-23,-20,-19,-22,-7,-1,-8,-19,-25,-22,-25,-22,-18,-28,6,184,131,-166,-80,55,-22,-6,6,4,13,10,20,28,33,36,40,41,38,36,34,7,-22,-28,-31,-36,-31,-29,-29,-22,-18,-17,-16,-16,-6,-5,-12,-19,-20,-23,-18,-17,-19,-19,103,220,-48,-177,30,20,-18,12,-8,4,16,16,22,24,27,38,43,41,39,33,23,4,-23,-36,-34,-29,-31,-29,-23,-22,-18,-13,-14,-10,-4,-6,-17,-24,-14,-14,-18,-17,-18,-17,125,210,-76,-144,46,10,-4,22,1,13,20,23,28,34,41,49,50,50,46,32};

// Baby 142bpm 15s-20s
//int32_T Voltages2[500]={18,-30,9,-4,5,18,20,17,24,41,52,51,43,41,44,21,-13,-29,-31,-40,-46,-34,-12,-7,-8,9,21,33,46,33,16,29,40,34,34,30,10,29,200,131,-197,-125,21,-53,-41,-27,-29,-11,-4,0,0,12,26,26,27,28,22,12,-10,-34,-39,-41,-56,-54,-41,-44,-50,-37,-17,-17,-23,-24,-35,-41,-40,-36,-39,-42,-27,132,166,-140,-148,34,-29,-29,-5,-19,1,10,12,11,13,22,24,22,33,39,17,-4,-12,-20,-30,-35,-36,-44,-39,-27,-30,-20,-5,-4,-13,-22,-20,-20,-20,-13,-13,-12,30,195,150,-171,-119,53,-10,-10,-2,-8,13,10,9,15,38,67,45,1,9,16,-7,-18,-20,-29,-29,-29,-31,-23,-20,-25,-28,-18,-4,-5,-11,-24,-36,-34,-27,-27,-33,-18,79,196,-16,-245,-65,4,-81,-64,-47,-8,12,17,39,43,35,23,17,18,11,-2,-13,-19,-18,-14,-13,0,11,5,-1,-8,-13,-13,-4,10,5,-8,-24,-29,-34,-34,-24,-16,12,159,192,-113,-157,39,7,-1,23,7,17,21,23,21,29,33,35,36,23,20,16,3,-8,-18,-22,-20,-16,-16,-22,-22,-5,9,10,1,-14,-19,-22,-22,-16,-12,-18,-17,26,177,129,-171,-114,50,-11,-1,21,7,15,21,29,39,41,35,38,39,39,49,41,18,1,-10,-17,-23,-22,-16,-16,-23,-27,-23,-17,-13,-22,-27,-29,-29,-27,-18,-16,-12,11,164,205,-124,-170,46,6,-13,12,-8,0,6,17,32,41,52,66,53,35,41,30,-6,-22,-16,-22,-35,-36,-33,-30,-27,-23,-17,-17,-28,-35,-40,-41,-37,-29,-39,-48,-30,148,201,-149,-188,33,-10,-14,21,10,21,20,23,38,51,58,62,62,62,62,52,24,-11,-29,-28,-27,-25,-36,-46,-24,-10,-13,-11,-16,-25,-36,-39,-33,-30,-30,-34,-39,119,201,-113,-168,43,-5,-19,18,1,6,-5,1,10,12,29,44,53,53,50,41,12,-19,-36,-52,-56,-50,-34,-23,-34,-29,-14,-13,-19,-29,-35,-27,-29,-36,-31,-24,-22,102,232,-41,-199,4,5,-31,9,-1,1,5,15,23,33,32,18,24,41,34,22,15,-16,-44,-40,-36,-40,-36,-51,-54,-30,-14,-13,-17,-23,-25,-30,-27,-22,-23,-24,-19,-18,79,234,10,-196,1,38,-22,6,0,13,9,5,21,26,28,40,51,50,35,24,15,-17,-28,-29,-41,-46,-36,-25,-33,-34,-35,-24,-11,-25,-41,-39,-28,-27,-37,-37,-28,27,192,74,-187,-45};
//int32_T Voltages[1];
// Baby 142 bpm 0s-5s
//int32_T Voltages[500] = {-22,-20,-22,-31,-26,-9,-7,-7,-5,-5,-7,-13,-13,-7,4,1,-8,44,199,94,-182,-73,41,-31,-10,-1,-9,-4,-4,2,12,15,20,28,21,10,2,-13,-30,-49,-59,-53,-42,-31,-20,-16,-14,-1,8,15,16,4,-4,-1,3,-4,4,10,7,44,205,147,-152,-79,65,-5,8,21,10,21,24,26,30,38,43,42,41,39,31,25,8,-12,-18,-22,-30,-30,-26,-26,-24,-14,-5,-1,-8,-15,-19,-21,-22,-20,-15,-16,-19,53,220,73,-182,-30,48,-28,4,-2,-10,4,10,16,24,30,31,36,42,42,31,20,5,-13,-24,-26,-26,-26,-21,-16,-20,-18,-9,-8,-9,-8,-13,-20,-14,-9,-8,-12,-15,15,170,138,-150,-93,61,-7,-2,12,4,18,13,19,31,38,44,43,43,48,48,37,24,8,-18,-38,-35,-21,-12,-9,-16,-20,-13,-5,3,4,-3,-7,-13,-22,-20,-13,-15,-21,26,202,125,-167,-75,50,-15,9,15,3,14,19,25,27,37,38,27,33,45,38,28,13,-8,-16,-30,-42,-33,-24,-21,-16,-20,-19,-8,-1,-7,-12,-14,-20,-27,-24,-9,-16,-25,8,178,153,-162,-113,56,-14,-9,14,4,8,3,15,30,38,44,54,53,37,30,33,22,-5,-22,-27,-32,-35,-30,-21,-20,-20,-19,-10,-2,-9,-22,-30,-25,-25,-24,-22,-27,-13,155,178,-128,-117,50,-10,-8,9,1,14,14,20,31,42,45,49,50,53,52,42,28,8,-4,-9,-10,-4,-1,-2,-10,-4,12,18,12,-5,-15,-27,-32,-35,-41,-28,-26,3,191,165,-145,-87,49,-26,-12,-5,-14,3,9,15,18,30,42,43,45,41,26,18,-1,-24,-36,-38,-45,-55,-50,-41,-48,-42,-27,-27,-25,-21,-26,-33,-28,-31,-28,-25,-32,-35,99,214,-59,-169,28,4,-31,-1,-12,-1,3,10,24,28,31,32,31,37,31,25,21,-14,-49,-56,-50,-49,-50,-44,-31,-35,-33,-22,-14,-4,-10,-18,-25,-30,-27,-21,-14,-18,-27,94,205,-49,-164,19,2,-28,4,-5,3,7,10,25,31,30,37,43,48,42,32,21,-4,-14,-19,-26,-27,-28,-26,-25,-21,-8,-10,-19,-3,3,-9,-18,-9,-9,-22,-25,-15,-15,75,232,28,-186,-4,31,-27,20,16,12,20,25,32,39,47,49,42,45,52,44,30,-4,-27,-24,-25,-33,-33,-30,-28,-31,-33,-26,-21,-26,-27,-27,-35,-36,-25,-5,-19,-37,-41,79,232,-24,-187,27,30,-22,10,-14,-13,3,9,15,16,12};
// Post bug
//int32_T Voltages[500] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-2,-14,-19,-10,-3,-2,-12,-19,-20,-22,-19,-16,-16,-20,-16,10,146,173,-116,-151,41,7,-10,19,13,22,22,25,35,45,49,45,42,38,32,27,27,12,-4,-9,-22,-27,-19,-9,-3,5,20,12,-10,-12,-5,-3,4,9,7,4,43,199,128,-169,-81,52,-27,-7,14,8,13,13,16,27,43,44,48,53,49,39,27,9,-8,-20,-22,-20,-22,-31,-26,-9,-7,-7,-5,-5,-7,-13,-13,-7,4,1,-8,44,199,94,-182,-73,41,-31,-10,-1,-9,-4,-4,2,12,15,20,28,21,10,2,-13,-30,-49,-59,-53,-42,-31,-20,-16,-14,-1,8,15,16,4,-4,-1,3,-4,4,10,7,44,205,147,-152,-79,65,-5,8,21,10,21,24,26,30,38,43,42,41,39,31,25,8,-12,-18,-22,-30,-30,-26,-26,-24,-14,-5,-1,-8,-15,-19,-21,-22,-20,-15,-16,-19,53,220,73,-182,-30,48,-28,4,-2,-10,4,10,16,24,30,31,36,42,42,31,20,5,-13,-24,-26,-26,-26,-21,-16,-20,-18,-9,-8,-9,-8,-13,-20,-14,-9,-8,-12,-15,15,170,138,-150,-93,61,-7,-2,12,4,18,13,19,31,38,44,43,43,48,48,37,24,8,-18,-38,-35,-21,-12,-9,-16,-20,-13,-5,3,4,-3,-7,-13,-22,-20,-13,-15,-21,26,202,125,-167,-75,50,-15,9,15,3,14,19,25,27,37,38,27,33,45,38,28,13,-8,-16,-30,-42,-33,-24,-21,-16,-20,-19,-8,-1,-7,-12,-14,-20,-27,-24,-9,-16,-25,8,178,153,-162,-113,56,-14,-9,14,4,8,3,15,30,38,44,54,53,37,30,33,22,-5,-22,-27,-32,-35,-30,-21,-20,-20,-19,-10,-2,-9,-22,-30,-25,-25,-24,-22,-27,-13,155,178,-128,-117,50,-10,-8,9,1,14,14,20,31,42,45,49,50,53,52,42,28,8,-4,-9,-10,-4,-1,-2,-10,-4,12,18,12,-5,-15,-27,-32,-35,-41,-28,-26,3,191,165,-145,-87,49,-26,-12,-5,-14,3,9,15,18,30,42,43,45,41,26,18,-1,-24,-36,-38,-45,-55,-50,-41,-48,-42,-27,-27,-25,-21,-26,-33,-28,-31,-28,-25,-32,-35,99,214,-59,-169,28,4,-31,-1,-12,-1,3,10,24,28,31,32,31,37,31,25,21,-14,-49,-56,-50,-49,-50,-44,-31,-35,-33,-22,-14,-4,-10,-18,-25,-30,-27,-21,-14,-18,-27,94};
// 230bpm
//int32_T Voltages[500] = {35,-62,-132,-143,-157,-155,-160,-159,-164,-170,-107,-47,-7,-132,-176,-235,251,736,-248,-446,-53,-230,-20,89,108,55,-104,-201,-273,-286,-298,-297,-299,-298,-301,-310,-247,-187,-139,-257,-308,-368,55,629,-294,-613,-182,-351,-167,-34,-16,-52,-210,-309,-384,-400,-408,-408,-407,-407,-405,-417,-357,-296,-236,-336,-402,-458,-143,550,-231,-753,-280,-418,-287,-113,-98,-108,-262,-366,-444,-465,-473,-473,-467,-467,-459,-473,-421,-355,-288,-354,-446,-486,-305,470,-47,-817,-360,-410,-367,-144,-126,-107,-248,-362,-442,-474,-476,-479,-468,-467,-456,-467,-428,-357,-286,-308,-424,-447,-394,367,228,-755,-429,-321,-389,-127,-92,-54,-167,-296,-377,-421,-422,-423,-411,-406,-395,-399,-378,-303,-231,-210,-334,-354,-382,250,520,-532,-482,-184,-334,-79,0,40,-29,-172,-257,-313,-316,-317,-307,-297,-286,-281,-277,-204,-134,-79,-188,-228,-279,156,747,-173,-488,-42,-205,-12,132,163,140,-10,-100,-167,-178,-177,-168,-156,-149,-136,-142,-79,-7,66,-10,-82,-124,123,879,240,-416,66,-23,67,275,298,312,169,66,-7,-29,-27,-23,-8,-2,13,5,53,126,203,166,64,39,149,932,615,-275,133,164,152,403,429,461,335,217,140,107,108,108,123,126,142,133,167,241,318,310,192,172,203,942,891,-113,167,314,228,493,533,569,462,331,250,206,205,201,216,217,230,223,246,319,390,401,277,256,246,924,1052,13,172,400,273,535,590,623,530,390,304,253,251,244,255,255,266,258,272,342,411,432,303,278,249,879,1113,69,141,417,269,521,588,617,532,387,298,241,236,226,234,232,240,233,240,308,372,398,268,239,201,803,1086,47,68,367,210,456,527,553,472,323,230,169,163,150,155,150,158,148,153,220,283,308,176,144,101,690,1000,-41,-47,266,102,343,418,441,361,209,116,52,43,29,34,29,33,23,24,90,152,180,46,12,-35,540,877,-164,-194,130,-39,199,278,300,224,70,-25,-92,-102,-115,-113,-119,-115,-124,-125,-59,1,33,-99,-136,-188,361,746,-284,-364,-18,-190,41,130,150,81,-74,-170,-236,-248,-262,-259,-263,-261,-265,-270,-206,-145,-108,-234,-276,-333,171,637,-362,-533,-148,-325,-109,-4,20,-37,-195,-291,-361,-373,-384,-383,-383,-382,-383,-391,-327,-265,-216,-333,-384,-444,-13,560,-370,-681,-248,-418,-230,-97,-77,-113,-270,-368,-441,-456,-464,-462,-459,-457,-453,-465,-404,-341,-280,-378,-442,-497,-170,517,-280,-781,-309,-450,-310,-138,-121,-132,-286,-389,-464,-482}; // Produces different results
//int32_T Voltages[500] = {92,-441,26,-110,14,186,195,178,19,-89,-170,-192,-204,-207,-205,-209,-207,-226,-173,-112,-50,-141,-221,-276,-10,710,4,-597,-127,-244,-142,44,53,45,-111,-221,-302,-328,-338,-341,-339,-342,-336,-355,-305,-243,-178,-255,-344,-391,-180,575,-25,-728,-261,-344,-277,-68,-58,-53,-204,-317,-398,-427,-433,-438,-432,-435,-425,-443,-397,-333,-264,-321,-422,-460,-315,462,22,-802,-364,-385,-367,-135,-119,-100,-241,-358,-441,-475,-477,-481,-472,-473,-461,-476,-437,-369,-298,-328,-442,-469,-392,379,146,-795,-427,-362,-403,-147,-121,-92,-215,-339,-421,-460,-461,-464,-453,-452,-437,-448,-418,-345,-272,-275,-398,-419,-399,327,328,-695,-447,-276,-375,-108,-62,-26,-129,-261,-341,-387,-387,-390,-376,-373,-358,-362,-342,-266,-195,-173,-296,-316,-336,312,535,-512,-421,-145,-287,-26,47,84,7,-134,-218,-269,-269,-270,-256,-250,-236,-233,-222,-146,-75,-33,-153,-179,-220,339,742,-276,-355,8,-155,85,187,221,165,20,-64,-122,-123,-124,-111,-104,-92,-85,-81,-7,65,119,7,-28,-77,402,926,-36,-255,161,-4,209,336,364,325,178,89,27,24,21,33,42,53,60,60,132,202,262,156,112,61,485,1072,165,-148,294,134,324,467,490,460,311,220,155,150,145,155,162,172,180,175,244,312,373,270,221,168,569,1176,295,-58,390,233,414,561,580,552,401,306,238,231,225,233,238,244,252,244,312,378,436,329,281,226,631,1227,335,-5,436,277,458,601,619,585,431,335,266,256,248,254,256,262,265,258,323,389,442,328,281,224,655,1214,290,-1,424,258,449,580,597,555,399,302,232,222,212,216,215,220,220,213,277,339,386,266,221,164,629,1138,178,-49,355,182,387,502,519,467,311,215,144,134,121,124,122,124,121,115,178,239,279,155,112,55,551,1015,26,-145,237,64,277,381,398,339,182,85,16,4,-10,-7,-12,-9,-14,-20,43,104,141,14,-27,-84,422,871,-127,-282,94,-82,135,236,254,192,36,-61,-132,-142,-157,-155,-159,-158,-163,-169,-106,-47,-7,-132,-175,-235,252,736,-248,-445,-53,-230,-20,89,108,55,-104,-201,-272,-285,-298,-296,-299,-298,-300,-310,-247,-186,-139,-256,-307,-368,55,630,-294,-613,-181,-351,-167,-33,-15,-52,-209,-309,-384,-399,-408,-408,-407,-407,-404,-416,-357,-295,-236,-335,-402,-458,-142,551,-231,-752,-279,-418,-287,-112,-98,-107,-261,-365,-443,-465,-472,-472,-466,-466,-459,-472,-420,-355,-288,-353,-445,-485,-305,471,-47,-816,-359,-409,-367};
// Post bug
//int32_T Voltages[500] = {1,1,1,1,2,8,3,1,4,1,7,2,10,-1,9,-2,5,2,1,8,122,698,439,-8,336,298,382,572,575,545,392,287,214,198,190,188,191,188,198,184,242,304,362,258,195,135,483,1135,305,-146,312,161,311,469,479,455,296,192,115,96,84,83,83,81,84,67,124,184,242,140,72,13,341,1009,203,-282,180,33,172,335,345,323,163,58,-22,-43,-55,-58,-58,-61,-59,-77,-21,38,96,-2,-75,-133,170,861,92,-441,26,-110,14,186,195,178,19,-89,-170,-192,-204,-207,-205,-209,-207,-226,-173,-112,-50,-141,-221,-276,-10,710,4,-597,-127,-244,-142,44,53,45,-111,-221,-302,-328,-338,-341,-339,-342,-336,-355,-305,-243,-178,-255,-344,-391,-180,575,-25,-728,-261,-344,-277,-68,-58,-53,-204,-317,-398,-427,-433,-438,-432,-435,-425,-443,-397,-333,-264,-321,-422,-460,-315,462,22,-802,-364,-385,-367,-135,-119,-100,-241,-358,-441,-475,-477,-481,-472,-473,-461,-476,-437,-369,-298,-328,-442,-469,-392,379,146,-795,-427,-362,-403,-147,-121,-92,-215,-339,-421,-460,-461,-464,-453,-452,-437,-448,-418,-345,-272,-275,-398,-419,-399,327,328,-695,-447,-276,-375,-108,-62,-26,-129,-261,-341,-387,-387,-390,-376,-373,-358,-362,-342,-266,-195,-173,-296,-316,-336,312,535,-512,-421,-145,-287,-26,47,84,7,-134,-218,-269,-269,-270,-256,-250,-236,-233,-222,-146,-75,-33,-153,-179,-220,339,742,-276,-355,8,-155,85,187,221,165,20,-64,-122,-123,-124,-111,-104,-92,-85,-81,-7,65,119,7,-28,-77,402,926,-36,-255,161,-4,209,336,364,325,178,89,27,24,21,33,42,53,60,60,132,202,262,156,112,61,485,1072,165,-148,294,134,324,467,490,460,311,220,155,150,145,155,162,172,180,175,244,312,373,270,221,168,569,1176,295,-58,390,233,414,561,580,552,401,306,238,231,225,233,238,244,252,244,312,378,436,329,281,226,631,1227,335,-5,436,277,458,601,619,585,431,335,266,256,248,254,256,262,265,258,323,389,442,328,281,224,655,1214,290,-1,424,258,449,580,597,555,399,302,232,222,212,216,215,220,220,213,277,339,386,266,221,164,629,1138,178,-49,355,182,387,502,519,467,311,215,144,134,121,124,122,124,121,115,178,239,279,155,112,55,551,1015,26,-145,237,64,277,381,398,339,182,85,16,4,-10,-7,-12,-9,-14,-20,43,104,141,14,-27,-84,422,871,-127,-282,94,-82,135,236,254,192,36};
// Mihir 60bpm
//int32_T Voltages[500] = {6,14,-36,-1,77,201,412,689,925,118,148,412,553,653,751,540,-31,-79,-106,-29,-11,40,-33,-61,-62,-152,-88,-105,97,145,60,28,-97,-37,-12,31,32,-12,-36,-71,-80,20,29,26,40,-15,27,61,31,88,40,122,25,-22,-29,-121,-71,-103,2,7,-58,1,3,32,4,-23,-45,-64,-84,-49,-54,-22,-45,-85,-18,-57,35,-21,-2,20,-32,32,-37,11,-56,-57,10,-35,38,22,-13,-55,-46,-20,42,3,33,10,-38,33,-12,26,-79,-31,-6,-33,24,-19,37,-70,78,770,11,-527,-1163,-811,199,563,501,419,90,-111,-101,-97,-46,-34,-5,-62,44,55,101,88,102,122,-112,-93,46,50,23,31,-16,-41,-24,16,21,-14,39,26,-8,-27,3,34,-33,-18,21,-8,-30,-21,36,29,5,-15,-53,-79,-55,-59,3,3,38,33,-6,13,48,12,25,9,79,29,-43,1,-29,-35,-77,-32,-44,18,-10,21,21,-3,-17,20,-19,34,43,33,70,7,-20,-42,-43,64,41,10,28,-89,-12,285,785,-967,-1129,-465,-193,273,553,192,97,-51,-102,-112,-85,-51,-92,-104,-35,-48,-3,-15,57,102,4,28,-3,49,89,92,149,74,67,26,25,53,14,11,-20,-22,44,23,-3,41,12,36,-54,-69,-44,24,66,47,89,21,29,33,14,-7,-51,-60,-21,-35,20,57,43,79,36,8,15,-11,15,-53,-16,36,35,27,1,47,15,-12,-13,30,29,-1,57,13,-38,-65,-50,-84,-36,-18,23,-20,-71,-112,-67,856,-1129,-1214,-1182,-955,-142,684,23,-25,-68,-125,-186,-126,-16,0,41,47,27,50,104,76,44,41,48,-64,40,64,50,17,-8,9,-46,-74,-10,-40,14,-3,6,-45,-40,-20,-25,-5,5,-15,-10,-10,0,43,4,-10,33,-19,29,-18,18,6,-14,39,14,36,-8,1,9,-47,-8,-26,-5,61,60,78,32,6,18,-42,-60,-53,-27,39,3,57,27,0,31,3,-27,-147,-27,21,118,42,16,-84,-108,-26,63,218,645,814,836,-1039,-38,272,478,634,737,218,34,-178,-127,-65,-17,46,15,14,38,17,-5,-1,25,4,-14,13,39,20,83,-116,-183,-208,-184,-170,-64,112,127,100,44,-40,-47,75,65,-26,-59,-48,62,66,74,41,49,48,-29,-23,1,-21,-47,-59,-25,185,174,196,196,92,70,-111,-110,-135,-118,-84,-96,-90,-25,-31,-45,-48,1,-1,-66,-31,-25,-38,-40,47,46,8,25,-23,29,-12,-47,-29,-25,-18,12,27,-19,-69,-24,154};

// Fabio 66bpm
//int32_T Voltages[500] = {-9,-21,-6,12,28,16,9,5,32,2,5,-26,12,55,36,21,32,59,17,-21,26,-2,55,26,63,-2,-55,-13,-18,-38,-17,47,87,119,95,63,63,856,426,32,-401,-827,-1026,-994,231,340,357,257,184,116,-11,31,63,59,36,69,32,-17,-26,13,36,-4,-6,27,-202,-223,-156,8,134,-67,-78,-100,-72,-22,18,-64,-55,-43,-63,-92,-69,17,-29,-19,-19,-49,-90,-7,-29,-10,-1,-21,-50,-4,25,33,38,84,120,97,-47,70,106,97,67,53,-12,4,30,32,8,-7,2,-69,-104,-77,-21,53,428,-945,-749,-506,-238,7,238,-42,-27,1,-12,-6,41,-17,-21,1,-4,-32,-53,7,-5,-38,-47,-20,9,6,48,30,-26,-80,-97,104,67,85,86,58,35,55,33,4,11,33,25,-20,35,14,-24,-43,-37,-36,39,11,-32,-49,-34,-16,52,17,10,35,49,29,29,53,68,92,75,26,5,3,25,-1,-37,-47,-40,-46,51,19,-2,-3,-25,-73,813,655,362,-185,-645,-1089,-554,36,359,361,221,45,-18,19,-17,13,38,94,46,10,-1,-72,-29,-66,30,51,3,0,8,19,-3,-69,-70,-8,-13,53,61,27,77,133,141,124,91,-25,-46,-108,-90,-73,-125,-1,-12,19,36,70,59,22,-83,80,69,37,39,-7,4,29,43,29,14,77,52,50,87,113,100,72,8,-49,-41,-7,15,2,8,-48,-81,-113,-94,-16,437,527,-113,-1190,-1090,-457,173,320,193,61,54,73,27,-38,-80,-119,-59,9,78,70,36,41,26,4,10,-25,20,29,-8,10,-103,-97,-10,16,74,67,78,48,55,-29,8,-6,11,42,31,-34,-12,-12,-27,-15,-56,48,74,9,42,-4,24,-1,-40,-12,-20,29,41,21,33,49,17,-12,-16,-8,-10,15,11,-38,8,-26,-23,83,74,88,56,34,-88,-123,-30,8,95,48,42,-82,-12,87,220,416,160,-555,-748,-267,16,187,286,88,52,42,46,25,-22,-58,-6,23,14,8,37,56,5,37,18,5,23,53,24,12,-12,-44,-20,-38,-16,41,64,60,19,57,87,7,-17,-8,-7,-46,-34,-23,-35,-28,1,-2,-3,79,68,34,16,32,-22,25,41,33,9,-3,16,26,28,46,35,-2,-15,54,70,2,-8,-46,-22,-47,-9,40,75,64,74,-19,-63,-50,-27,4,11,73,40,6,35,-2,-4,62,809,686,-559,-1069,-1072,-291,336,339,134,112,20,-10,-30,17,-1,-20,9,-9,45,12,-14,36,4,53,37,38};

// John 74bpm
//int32_T Voltages[500] = {62,59,43,26,-9,-46,-33,-24,-17,-17,0,-29,18,287,608,290,-690,-1154,63,381,296,211,67,-35,-39,-27,-22,-30,-30,-24,37,49,47,42,34,35,4,-38,-8,6,16,11,-6,-70,-60,-48,-24,-4,13,31,39,32,24,19,2,-13,34,44,49,49,44,-17,33,45,46,35,21,-24,61,57,54,46,31,-8,-8,3,6,5,-2,-21,-47,-25,15,75,51,21,-43,-71,-41,-30,-7,-10,-13,-38,-31,402,701,651,-524,-930,-327,504,553,317,54,-9,4,-2,-3,-10,5,-6,5,20,21,22,-1,-11,-6,-14,-11,-15,-9,1,-10,-28,-53,-49,-26,13,10,-10,-52,-44,-16,24,17,13,-1,-17,-4,7,31,17,2,-8,-14,-22,-21,-13,6,36,32,37,24,-10,-12,-16,-30,-50,-50,-4,4,29,40,45,35,0,-53,-63,-17,-9,12,6,-19,-49,168,329,748,426,-1201,-1065,317,486,558,299,-94,-105,-44,-31,-17,14,34,27,71,72,73,57,21,-40,-43,-45,-48,-37,-19,-9,-56,-51,-47,-43,7,58,-14,-16,-13,-12,4,21,32,27,13,-1,-52,-96,41,25,11,2,-6,-22,18,39,41,25,0,-1,11,7,-11,-27,-24,-26,16,24,19,19,0,-3,0,25,13,-51,-67,-47,-14,25,35,-31,-53,-38,312,463,-376,-1213,-1178,-389,335,213,61,-63,-69,-52,16,62,27,-1,-2,-10,-4,43,8,-43,-111,-103,-58,8,63,60,47,-5,-41,-46,-46,-47,-10,2,10,23,33,21,18,34,43,57,40,-29,-39,-54,-46,-36,-10,-23,-20,-10,1,8,18,12,9,8,6,-3,-16,24,-68,-77,-73,-55,-34,-5,0,-10,-30,-46,-54,-60,7,13,10,2,-14,-26,-60,512,-154,-560,-894,-1223,131,60,6,-23,-33,-39,-38,-21,-7,9,30,51,65,11,8,8,0,-11,-17,38,45,37,24,12,-30,-16,5,20,27,25,24,3,4,3,7,16,24,25,8,12,7,-1,-4,2,-63,-65,-56,-42,-31,-23,6,-1,-4,0,14,32,66,-47,-42,-43,-45,-42,-36,31,24,19,13,9,8,-48,-48,-36,3,8,20,177,381,586,700,725,510,-223,574,580,527,444,303,164,-92,-87,-60,-3,2,-10,42,44,47,49,44,32,-34,-23,-18,-18,-11,-1,7,-33,-50,-79,-70,-59,-12,30,25,21,7,0,-2,-8,-9,-4,-1,-4,-10,-5,25,24,14,5,1,-10,-4,-17,-33,-24,-9,23,17,2,-15,-17,-16,-17,17,26,42,30,25,15,-66,-64};
int32_T Voltages[FS * SAMPLE_TIME];
// Eric 70bpm
//int32_T Voltages[500] = {37,30,4,23,6,-27,25,53,45,13,100,-57,-80,-30,39,45,-51,-42,33,-55,55,-6,-9,302,519,707,-142,-1053,-966,560,430,77,-26,-29,-215,-31,75,138,77,-7,6,-31,-92,-39,47,138,-7,-36,-35,-38,112,84,6,-79,-65,-129,-150,-61,-20,34,139,71,-31,72,31,33,-85,-33,-21,54,49,-42,-5,17,-66,11,19,23,17,37,32,-8,-33,-31,-65,-12,54,47,3,1,37,-66,-75,-11,35,130,-38,-48,-43,-97,4,-14,-25,52,2,35,27,-107,16,300,686,-605,-1112,-303,5,536,430,-103,-226,-14,-16,-68,-12,-83,-133,-29,66,66,93,-43,-97,-16,13,87,-32,243,153,-117,-128,-82,-48,-65,-57,40,63,38,71,118,-102,-83,-41,-55,-51,91,184,-74,-52,36,75,18,-81,-87,-99,-35,83,132,-12,70,113,86,38,58,123,-123,-160,-10,-4,6,14,53,-6,9,19,-22,-60,122,183,99,108,51,175,-15,-395,-237,258,488,578,-332,-820,-527,513,586,466,69,54,-13,-15,-120,-126,-131,36,77,96,106,66,284,133,59,27,-114,10,-129,14,22,-67,-223,-173,-113,-38,247,153,170,123,62,6,-84,-96,-146,-121,-150,-26,-8,-20,40,-34,95,-33,19,-28,-58,-132,-74,0,68,82,42,82,27,101,54,25,31,14,19,-80,66,-75,8,138,-1,-29,-85,-109,53,30,20,95,209,650,-439,-1093,-147,149,360,404,-59,-32,33,-13,-20,65,-39,-13,-3,7,8,29,-10,28,-21,50,65,39,115,117,-49,-80,-55,-75,-184,-95,38,10,-32,-1,94,-16,46,82,53,-14,-35,-30,-56,-27,-8,-55,-134,-68,-11,-36,45,21,120,0,-130,-20,38,42,-45,44,-110,-151,82,109,67,-115,-97,-52,-57,144,44,-36,-15,417,569,-244,-753,-908,-413,400,330,143,27,-109,-82,27,5,107,-92,30,-1,41,3,-66,-27,-64,-6,58,39,-29,-8,-48,55,-29,-188,-116,-37,-5,-95,87,146,80,110,-68,37,-149,41,120,41,24,-18,-10,93,70,108,-7,-183,-67,-115,97,112,23,61,-30,-36,73,36,-68,-22,33,-25,38,23,17,-28,-4,-83,32,-55,31,5,-52,78,-88,-39,160,641,475,222,-666,-178,142,379,241,66,-34,7,-100,-2,-11,30,-24,72,2,70,13,-4,72,-73,-14,65,35,-27,-23,69,18,-121,-51,-68,-133,-84,119,-28,-63,-38,13,1,97,136,57,9,38,52,-114,32,13,-38,-39,29,45,-65,-27,59,-30,67,0,92,-62,-132};

// Alison 66bpm
//int32_T Voltages[500] = {-4,-66,53,111,64,22,-60,30,-50,-53,44,20,87,-25,-34,-24,22,-10,27,15,-30,49,226,1040,711,-407,-1174,-60,134,297,313,161,136,1,-41,11,1,19,18,92,68,31,-2,29,2,26,86,21,6,-22,11,-110,-107,-80,60,30,53,128,50,36,-49,-69,-139,-250,-264,-206,-97,-84,-124,-199,-182,170,151,100,96,91,-13,24,161,105,59,78,121,-49,158,123,38,-28,-37,-51,85,86,111,96,53,106,45,18,62,41,46,-26,-158,-106,-3,175,563,807,-1005,-927,-344,-19,280,241,185,-26,-68,-38,-38,25,102,45,21,61,40,49,-24,6,71,64,62,-37,4,-127,-221,-103,-98,49,5,36,66,9,40,7,70,87,77,45,53,-16,-18,-41,-52,-19,-8,11,-39,33,-33,15,10,-36,-2,52,28,-73,61,8,5,52,75,69,85,-13,-31,11,72,-112,-52,-1,0,-6,-12,-2,-50,-67,-19,6,-21,72,20,38,-37,105,412,1059,-822,-1240,-367,-174,226,296,93,149,119,109,5,43,-47,-33,77,71,0,-17,6,65,-25,4,31,3,-41,-83,-105,-65,-77,-64,23,72,140,102,28,-13,30,38,-22,14,38,10,-45,26,-20,4,42,5,-43,-3,24,-16,-65,-66,-17,-41,52,98,19,56,-36,20,-16,-52,12,-9,102,16,13,-26,-71,9,-31,30,34,19,18,13,2,43,-24,-14,35,48,90,-43,-13,-9,-8,83,28,85,-41,-101,500,874,71,-861,-1198,-602,197,404,329,195,123,14,-69,-22,30,85,3,72,51,3,44,-26,55,30,66,64,4,-7,-64,-146,-199,-157,-51,132,149,208,95,-1,75,38,36,-82,16,3,-5,-10,-39,15,-38,-3,81,31,-26,-50,-17,-8,19,62,77,25,47,8,-25,42,25,-33,-84,-22,50,-24,-41,-4,64,31,49,-4,-21,5,65,53,38,-22,-37,-64,-39,6,-49,1,-3,-11,-33,-12,545,-7,-776,-540,-258,-23,273,193,-50,-75,-43,23,38,84,44,-15,-47,-23,18,-58,-7,49,3,65,-31,4,8,-84,-72,-117,-52,-81,8,72,17,100,30,37,99,97,95,-41,-45,-3,-56,-22,-3,9,51,-37,19,-23,-75,37,-10,70,-1,2,-15,61,32,2,38,48,-44,-29,-13,-8,35,-4,-26,-32,-21,25,-30,58,70,-1,-7,-68,-15,-59,41,70,-16,-12,-106,388,65,-1071,-1020,-493,-271,215,413,214,173,24,69,-32,-21,56,-11,-30,-95,-5,-49,50,83,168,132,76,40,59,-14,-162,-191,-220};

// Database 40bpm
//int32_T Voltages[500] = {-7,-24,-37,-48,-56,-63,-69,-74,-77,-81,-88,-104,-132,-167,-189,-166,-69,115,364,590,683,583,336,57,-155,-265,-284,-245,-188,-142,-116,-105,-100,-98,-94,-91,-88,-86,-85,-84,-79,-74,-65,-54,-42,-29,-13,5,24,46,68,90,112,133,152,169,182,190,195,195,190,180,166,148,127,104,81,56,32,7,-16,-36,-54,-71,-85,-97,-107,-114,-120,-125,-128,-131,-132,-133,-133,-133,-133,-133,-133,-132,-132,-131,-130,-128,-128,-127,-126,-125,-125,-124,-122,-121,-120,-120,-119,-117,-116,-115,-114,-114,-113,-111,-110,-109,-108,-108,-107,-105,-104,-103,-102,-100,-99,-99,-98,-97,-96,-93,-92,-91,-90,-88,-87,-85,-82,-77,-73,-65,-56,-42,-25,-6,16,39,63,84,101,112,115,112,100,83,61,36,13,-8,-25,-40,-48,-56,-62,-67,-70,-74,-76,-81,-92,-114,-147,-174,-170,-99,57,291,540,692,658,447,169,-64,-195,-228,-194,-134,-87,-60,-48,-44,-40,-35,-30,-27,-23,-20,-17,-12,-6,4,16,30,46,64,84,104,127,150,173,195,216,234,249,260,266,266,262,253,240,223,204,181,156,132,108,85,64,45,27,12,0,-11,-18,-25,-30,-34,-36,-37,-39,-39,-39,-37,-37,-36,-36,-35,-34,-33,-31,-31,-30,-29,-28,-27,-25,-25,-24,-23,-22,-20,-20,-19,-18,-17,-17,-16,-14,-14,-13,-12,-12,-11,-10,-10,-8,-7,-7,-6,-5,-5,-4,-4,-2,-1,-1,0,1,1,5,9,15,24,35,50,67,87,109,132,154,171,183,187,184,172,155,132,108,84,62,44,30,20,11,4,-2,-7,-11,-14,-20,-36,-64,-99,-116,-84,33,238,489,685,714,544,269,23,-122,-162,-128,-73,-28,-5,3,6,9,11,15,18,21,23,26,29,35,45,57,72,89,107,126,147,169,190,211,229,245,257,264,267,263,256,243,226,205,181,156,130,104,80,58,38,20,4,-10,-20,-29,-36,-42,-46,-50,-52,-53,-54,-56,-57,-57,-58,-58,-58,-59,-59,-59,-59,-59,-59,-60,-60,-60,-60,-60,-60,-60,-60,-62,-62,-62,-62,-62,-62,-62,-62,-63,-63,-63,-63,-63,-63,-63,-63,-63,-63,-63,-63,-63,-63,-63,-62,-60,-59,-56,-50,-42,-30,-16,3,24,47,69,87,101,107,104,95,76,55,30,6,-14,-31,-46,-57,-67,-74,-80,-84,-86,-91,-102,-126,-159,-183,-161,-56,144,395,587,600,418,142,-103,-251,-294,-265,-207,-159,-132,-121,-116,-114,-110,-105,-100,-98,-96,-92,-88,-81,-71,-59,-46,-29,-11,9,30,52,75,98};
#pragma SET_DATA_SECTION()

void init_i2c(){

  EALLOW;
  // Enable Clock routing to the I2C Module
  SysCtrlRegs.PCLKCR0.bit.I2CAENCLK = 1;
  EDIS;

  ///////////////////////////////////////////////
  ///////       GPIO Setup             //////////
  //////    SDA: GPIO28, SCL GPIO29    //////////
  ///////////////////////////////////////////////

  EALLOW;
  // Setup GPIO Modes
  GpioCtrlRegs.GPAMUX2.bit.GPIO28 = 2; // Set GPIO28 to i2c SDA function (2 == 0b10) (see below warning:)
  GpioCtrlRegs.GPAMUX2.bit.GPIO29 = 2; // Set GPIO29 to i2c SCL function (warning: if you use GPIO32 and GPIO 33 instead, the number is 1 (aka 0b01) not 2)

  // Disable Internal Pull Ups (already provided by master side)
  GpioCtrlRegs.GPAPUD.bit.GPIO28 = 0; // Disable Pull Up for GPIO28
  GpioCtrlRegs.GPAPUD.bit.GPIO29 = 0; // Disable Pull Up for GPIO29


  // Set qualifications type on SDA and SCL to async (digital signals from another micro don't need multiple validations)
  GpioCtrlRegs.GPAQSEL2.bit.GPIO28 = 3;
  GpioCtrlRegs.GPAQSEL2.bit.GPIO29 = 3; // 3 == 0b11

  EDIS;



  ///////////////////////////////////////////////
  //////////    Interrupt Setup    //////////////
  //////////////////////////////////////////////

  EALLOW;  // This is needed to write to EALLOW protected registers
	  PieVectTable.I2CINT1A = &i2c_int1; // Register the Interrupt handler for i2c in the PIE table

	  PieCtrlRegs.PIEIER8.bit.INTx1 = 1; // Enable Group 8 Subgroup 1 Interrupt in the PIE table

	  IER |= M_INT8; // Enable the CPU interrupt (8) that is responsible for this PIE group (group 8)
  EDIS;    // This is needed to disable write to EALLOW protected registers


  // Clear all status bits for the i2c module (reset)
  I2caRegs.I2CMDR.bit.IRS = 0;   // Technically this triggers a i2c reset

  // Enable i2c "addressed as slave" interrupt
  I2caRegs.I2CIER.bit.AAS = 1;
  I2caRegs.I2CIER.bit.SCD = 1;

  // Enable the XRDYINT (Transmit read condition interrupt). Enabled so I can see if data is getting to the transmit shift register
  I2caRegs.I2CIER.bit.XRDY = 1;

  // Change Clock divider
  I2caRegs.I2CPSC.all = 2;       // Prescaler - set to 128 giving module clk of SYSCLKOUT/129 => 465kHz

  // More clock stuff here
  I2caRegs.I2CCLKL = 5;     // NOTE: must be non zero
  I2caRegs.I2CCLKH = 5;     // NOTE: must be non zero


  // Setup the i2c module in slave mode
  I2caRegs.I2CMDR.bit.MST = 0;

  // Setup the i2c module as a receiver (so now we are in slave-reciever mode)
  I2caRegs.I2CMDR.bit.TRX = 0;

  // 7BIT address mode
  I2caRegs.I2CMDR.bit.XA = 0;

  // 8bit data mode
  I2caRegs.I2CMDR.bit.BC = 0;


  I2caRegs.I2CIER.bit.RRDY = 1;   // Enable Receive Interrupt

  // Set i2c address of this module
  I2caRegs.I2COAR = 0x48;

  I2caRegs.I2CCNT = 4;          // Get/send 4 bytes

  I2caRegs.I2CDXR = header_byte; // Fill the transmission buffer

  // Re-Enable the Module now that configuration is done
  I2caRegs.I2CMDR.bit.IRS = 1;


}


void main(void)
{
	

// Step 1. Initialize System Control:
// PLL, WatchDog, enable Peripheral Clocks
// This example function is found in the F2806x_SysCtrl.c file.
   InitSysCtrl();

// Step 2. Initalize GPIO:
// This example function is found in the F2806x_Gpio.c file and
// illustrates how to set the GPIO to it's default state.
// InitGpio();  // Skipped for this example

// Step 3. Clear all interrupts and initialize PIE vector table:
// Disable CPU interrupts
   DINT;

// Initialize the PIE control registers to their default state.
// The default state is all PIE interrupts disabled and flags
// are cleared.
// This function is found in the F2806x_PieCtrl.c file.
   InitPieCtrl();

// Disable CPU interrupts and clear all CPU interrupt flags:
   IER = 0x0000;
   IFR = 0x0000;

// Initialize the PIE vector table with pointers to the shell Interrupt
// Service Routines (ISR).
// This will populate the entire table, even if the interrupt
// is not used in this example.  This is useful for debug purposes.
// The shell ISR routines are found in F2806x_DefaultIsr.c.
// This function is found in F2806x_PieVect.c.
   InitPieVectTable();


   // Copy time critical and Flash modifying functions to RAM
   memcpy(&RamfuncsRunStart, &RamfuncsLoadStart, (Uint32)&RamfuncsLoadSize);


// Call Flash Initialization to setup flash waitstates
// This function must reside in RAM
   InitFlash();


   EALLOW;
   GpioCtrlRegs.GPAMUX1.bit.GPIO3 = 0; // Set as General Purpose on Mux
   GpioCtrlRegs.GPADIR.bit.GPIO3 = 1; // Set as ouput
   GpioDataRegs.GPASET.bit.GPIO3 = 1; // Set GPIO as 1 (HIGH)
   EDIS;

// Step 4. Initialize all the Device Peripherals:
// This function is found in F2806x_InitPeripherals.c
// InitPeripherals();  // Not required for this example
   InitEPwmTimer();    // For this example, only initialize the ePWM Timers
   init_adc();

   init_i2c();

// Initalize counters:
   LoopCount = 0;



// Enable global Interrupts and higher priority real-time debug events:
   EINT;   // Enable Global interrupt INTM
   ERTM;   // Enable Global realtime interrupt DBGM


   // Initialize Leads off detection hardware
   InitLeadsOffDetection();

   /** VITASIGN CODE **/

  	/**
  	 * Initializes the linked buffer structure
  	 */
	initLinkedBuffers();

  /**
   * CODE TO TEST LINKED BUFFERS
   */
	// Generates data to test circular linked list of buffers
//	int32_T data = 0, how_many_times = 0;
//
//	while(how_many_times != 80) {
//		data = (data + 1);
//		addData(data);
//		how_many_times++;
//	}
//  int32_T heart_rate=0, last_hr_delta=0;
//  int i;
//  	// Converts the DC values to fixed point values
//
//	for(i = 0; i < 500; i++) {
//		Voltages[i] = mul_s32_s32_s32_sat(Voltages[i], div_repeat_s32_sat_near(3379, 4096, 10U)); // 3379 is 3.3 is fixed point
//		Voltages[i] = (Voltages[i] >> 10) + ((Voltages[i] & 512L) != 0L);
//	}
//
////   	void heart_rate_official_cport(int32_T data[500], uint32_T fs, int32_T
////   	  threshold_1, int32_T threshold_2, int32_T threshold_3, int32_T
////   	  pos_deviance_threshold, int32_T neg_deviance_threshold, uint32_T sample_time,
////   	  uint32_T shouldOutput, int32_T prev_hr_delta, int32_T *heart_rate, int32_T
////   	  *last_hr_delta)
//  		long threshold_1 = 153;
//  		long threshold_2 = 307;
//  		long threshold_3 = 204;
//  		long pos_deviance = 5120;
////   		long neg_deviance = 716; // .7
//  		long neg_deviance = 768; //.75
//  		uint32_T sample_time = 5;
//  		uint32_T should_output = 0;
//  		int32_T prev_hr_delta = 0;
//  	   	heart_rate_official_cport(Voltages, 100, threshold_1, threshold_2, threshold_3, pos_deviance, neg_deviance, sample_time, should_output, prev_hr_delta, &heart_rate, &last_hr_delta);

	int i;
	for(i = 0; i < FS * SAMPLE_TIME; i++) {
		Voltages[i] = 0;
	}
	for(i=0; i < NUM_HRS_AVG; i++)
		heart_rates[i] = 0;

//  	// Converts the DC values to fixed point values
//	for(i = 0; i < 500; i++) {
//		Voltages2[i] = mul_s32_s32_s32_sat(Voltages2[i], div_repeat_s32_sat_near(3379, 4096, 10U)); // 3379 is 3.3 is fixed point
//		Voltages2[i] = (Voltages2[i] >> 10) + ((Voltages2[i] & 512L) != 0L);
//		Voltages[i] = Voltages2[i];
//	}

   for(;;)
   {
       // This loop will be interrupted, so the overall
       // delay between pin toggles will be longer.
//       DELAY_US(DELAY);
   }

}



/**
 * Adds data to the linked buffer list
 * @param val [description]
 */
static void addData(int32_T val) {
	(current_linked_buffer->buffer)[current_index] = val;

	// Checks if we are at the end of the buffer
	if (current_index == BUFFER_SIZE - 1) {
		// Updates the buffer full
		if(!buffers_full)
			num_empty_buffers_left--;

		current_linked_buffer = current_linked_buffer->next;
		/**
		 * Copies the data out of the linked buffer
		 * Starts copying from the next buffer b/c that will be the beginning
		 */
		if (!num_empty_buffers_left){
			copying = 1;
			// Tests if we are ever calculating and copying
			if(calculating == 1){
				copying = 0;
				return; // Waits til next copy cycle to run the algorithm on new data
			}
			copyDataOut(current_linked_buffer, Voltages);
			copying = 0;
			runHRAlgo();
			buffers_full = 1;
		}
	}
	// Updates where the next data in the current buffer should go
	current_index = (current_index + 1) % (BUFFER_SIZE);
}
static void initLinkedBuffers() {
	// Builds the circular linked list
	int i;
	for(i = 0; i < NUM_BUFFERS; i++){
		circular_buffers[i].next = &circular_buffers[(i+1) % (NUM_BUFFERS)];
	}
	// Initializes the head and the tail of the buffers
	linked_buffer_head = circular_buffers;
	linked_buffer_tail = &circular_buffers[NUM_BUFFERS - 1];
	// Initializes the pointer to the first buffer in the list
	current_linked_buffer = linked_buffer_head;
}
/**
 * Prints all the buffers in the circularly linked list of buffers
 * @param head
 * @param tail
 */
static void copyDataOut(Linked_Buffer *head, int32_T *buf) {
	IER &= ~M_INT1;  // This is a critical code section, lockout of the buffer is required for coherency
	Linked_Buffer *src_linked_buffer = head;
	unsigned int i, linked_buffer;
	/**
	 * Copies all the data out of the buffers in the linked list to buf
	 */
	for (linked_buffer=1; linked_buffer <= NUM_BUFFERS; linked_buffer++) {
		// Copies all the data out of the buffer
		for(i = 0; i < BUFFER_SIZE; i+=1)  {
			buf[i + ((linked_buffer - 1) * (BUFFER_SIZE))] = (src_linked_buffer->buffer)[i];
		}
		src_linked_buffer = src_linked_buffer->next;
	}
	// Release the lock
	IER |= M_INT1;

}
/**
 * Runs the HR algo using the Voltages array
 */
static void runHRAlgo() {
	  int32_T last_hr_delta=0;
	  int i;
	  	// Converts the DC values to fixed point values
		for(i = 0; i < 500; i++) {
			Voltages[i] = mul_s32_s32_s32_sat(Voltages[i], div_repeat_s32_sat_near(3379, 4096, 10U)); // 3379 is 3.3 is fixed point
			Voltages[i] = (Voltages[i] >> 10) + ((Voltages[i] & 512L) != 0L);
		}

	  		heart_rate = 0;
			calculating = 1;
//	  		heart_rate_official_cport(Voltages, 100, threshold_1, threshold_2, threshold_3, pos_deviance, neg_deviance, sample_time, should_output, prev_hr_delta, &heart_rate, &last_hr_delta);
			heart_rate_official_cport(Voltages, 100, threshold_1, threshold_2, threshold_3, pos_deviance, neg_deviance, prev_hr_delta, &hr_delta_sum, toss_thresh, &num_peak_deltas, neg_peak_deviance_threshold, sample_time, should_output, &heart_rate, &last_hr_delta);

	  		calculating = 0;
	  		// Grabs the heart rate value
	  		heart_rates[hr_index] = heart_rate;
			hr_index = (hr_index + 1) % NUM_HRS_AVG;
	  		// Ceilings the number of heart rate samples we average pver
	  		if(num_hrs < NUM_HRS_AVG_FI)
	  			num_hrs = plus(num_hrs); //1024 is = 1 in Q=10 Fixed Point
	  		else {
				// Averages the HR value over the last NUM_HRS
				int32_T hr_sum = 0;
				for(i=0; i < NUM_HRS_AVG; i++)
					hr_sum += heart_rates[i];
				hr_sum = (hr_sum >> 10) + ((hr_sum & 512L) != 0L); // Converts back to Q=10 Fixed Point from Q=20 Fixed point
				// Saves the heart rate average to the out variable
				heart_rate_avg = div_repeat_s32_sat_near(hr_sum, num_hrs, 10U);
				hr_sum = 0;
				num_hrs = 0;
	  		}
			// Resets the hr delta avg
			if (reset_counter < RESET_THRESH){
				reset_counter++;
			}
			else{
				num_peak_deltas  = 0;
				hr_delta_sum = 0;
				reset_counter = 0;
			}

//			for(i = 0; i < 500; i++) {
//				Voltages2[i] = Voltages[i];
//			}

}

void init_adc(){



	   InitAdc();  // Initialize the ADC (turns on ADC, turns on the ref and waits for it to stabilize...etc)


	   // Configure ADC
	   EALLOW; // Allow me to write to these protected Registers
	   AdcRegs.ADCCTL2.bit.ADCNONOVERLAP = 1;	// Enable non-overlap mode
	   AdcRegs.ADCCTL1.bit.INTPULSEPOS	= 1;	// ADCINT1 trips after AdcResults latch
	   AdcRegs.INTSEL1N2.bit.INT1E     = 1;	// Enabled ADCINT1
	   AdcRegs.INTSEL1N2.bit.INT1CONT  = 0;	// Disable ADCINT1 Continuous mode
	   AdcRegs.INTSEL1N2.bit.INT1SEL	= 1; // Trigger the ADCINT1 from EOC 1 (which is generated when SOC 1 finishes it's conversion)
	   AdcRegs.ADCSAMPLEMODE.bit.SIMULEN0 = 0; // DeCouple SOC0 and SOC1 -- set to 1 to re-couple

	   // Setup SOC0 for ADCINA1 from EPWM1 SOCA
	   AdcRegs.ADCSOC0CTL.bit.CHSEL 	= 1;    // set SOC0 channel select to ADCINA1
	   AdcRegs.ADCSOC0CTL.bit.TRIGSEL 	= 5;    // set SOC0 start trigger on EPWM1A
	   AdcRegs.ADCSOC0CTL.bit.ACQPS 	= 6;	// set SOC0 S/H Window to 7 ADC Clock Cycles, (6 ACQPS plus 1)

	   // Setup SOC1 for ADCINB0 from EPWM1 SOCA
	   AdcRegs.ADCSOC1CTL.bit.CHSEL		= 8;	// set SOC1 channel select to ADCINB0
	   AdcRegs.ADCSOC1CTL.bit.TRIGSEL 	= 5;    // set SOC0 start trigger on EPWM1A
	   AdcRegs.ADCSOC1CTL.bit.ACQPS 	= 6;	// set SOC1 S/H Window to 7 ADC Clock Cycles, (6 ACQPS plus 1)

	   EDIS; // Lock out all protected registers




	   // Remap the adc_isr to our own isr
	   EALLOW;  // This is needed to write to EALLOW protected register
	   PieVectTable.ADCINT1 = &adc_isr;
	   EDIS;    // This is needed to disable write to EALLOW protected registers


	   PieCtrlRegs.PIEIER1.bit.INTx1 = 1;	// Enable INT 1.1 in the PIE
	   IER |= M_INT1; 						// Enable CPU Interrupt 1 to allow PIE group 1 to make it to the CPU
	   // Don't Forget to enable global interrupts after call to this function, they are not enabled here in case this function is called before user is ready to enable all interrupts
	   // can be done like so:
	   // EINT;          						// Enable Global interrupt INTM

}


void InitEPwmTimer()
{
	// Initalize counters:
	EPwm1TimerIntCount = 0;

	// Interrupts that are used in this example are re-mapped to
	// ISR functions found within this file.
	EALLOW;  // This is needed to write to EALLOW protected registers
//	PieVectTable.EPWM1_INT = &epwm1_timer_isr; // I don't really want the interrupt for PWM to fire, just for it send a SOCA signal
	EDIS;    // This is needed to disable write to EALLOW protected registers


	EALLOW;
	SysCtrlRegs.PCLKCR0.bit.TBCLKSYNC = 0;      // Stop all the TB clocks (aka clks that run pwms)
	EDIS;

	//   InitEPwm1Gpio(); // Enables generation of PWM signal at EPWM1 pins, disabled to reduce noise

	// Setup pwm clock
	EPwm1Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1;
	EPwm1Regs.TBCTL.bit.CLKDIV    = 5; // Divide by 32 ( binary 101 )


	// Setup Sync
	EPwm1Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_DISABLE;  // Disable Sync output (no chaining of pwms, so not necssary)
	EPwm1Regs.TBCTL.bit.PHSEN = TB_DISABLE;	// Disable phase loading (since we aren't chaining pwms together)


	// Setup Counting Properties
	EPwm1Regs.TBPRD = PWM1_TIMER_TBPRD;
	EPwm1Regs.TBCTL.bit.CTRMODE = TB_COUNT_UP;    // Count up
	EPwm1Regs.TBCTR = 0x0 ; // Clear the counter	in prep. for first count

	// Setup PWM to trigger ADC through SOC-A
	EPwm1Regs.ETSEL.bit.SOCAEN = 1; // Enable the SOC-A line to the ADC
	EPwm1Regs.ETSEL.bit.SOCASEL = 1; // Trigger the SOC on Counter Equal Zero event
	EPwm1Regs.ETPS.bit.SOCAPRD = 1; // Send trigger down SOC A every 1 times that Counter Equal zero event occurs (as opposed to every 2 or 3 times)

	// Enable CPU INT3 which is connected to EPWM1-3 INT:
//	IER |= M_INT3;



	EALLOW;
	SysCtrlRegs.PCLKCR0.bit.TBCLKSYNC = 1;         // Start all the timers synced
	EDIS;

}

interrupt void i2c_int1(void){
  isr_counter++;


  IntSource = I2caRegs.I2CISRC.all;

  if( IntSource == I2C_AAS_ISRC){ // Addressed as slave
    num_rec_slave_addr++; // Good indicator to show that i2c module has recognized it's slave address

//    I2caRegs.I2CDXR = header_byte; // First time we are get called by the master we put get the header byte ready to send.
    current_shift_index = 0;
  }

  if (IntSource == I2C_TX_ISRC){ // Read requested

    num_bytes_moved_to_tx_shift ++; // Good indicator to show that i2c is shifting out values


    I2caRegs.I2CSTR.bit.XRDY = 1; // Clear the XRDY interrupt (re-arm it) since it does not get auto-cleared by reading I2CISRC


    I2caRegs.I2CDXR = heart_rate_avg>>shifts[current_shift_index]; // Update to newest value we have at time of call
    if(current_shift_index == 2){
    	current_shift_index = 0;
    }else{
    	current_shift_index++;
    }

  }

  if(IntSource == I2C_SCD_ISRC){ // Stop Condtion Detected
	  // This could potentially happen BEFORE we are able to shift out all 4 bytes.
	  //	hence why have to be ready for the next time they ask, to start the protocol from top

	  // Reset the pointer to start of hear_rate_avg
	  current_shift_index = 0;
	  // Reset the value of I2CDXR to unique_address
	  I2caRegs.I2CDXR = header_byte;
  }

  // Acknowledge this interrupt to receive more interrupts from group 8
  PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;
}


interrupt void adc_isr(void){
	LoopCount++;
	GpioDataRegs.GPBTOGGLE.bit.GPIO34 = 1;

	int adc_0 =  AdcResult.ADCRESULT0;
	int adc_1 = AdcResult.ADCRESULT1;
	  // If 20 conversions have been logged, start over
	  addData( (int32_T)(adc_0 - adc_1 ) );

	  AdcRegs.ADCINTFLGCLR.bit.ADCINT1 = 1;		//Clear ADCINT1 flag reinitialize for next SOC
	  PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;   // Acknowledge interrupt to PIE
}

// This ISR MUST be executed from RAM as it will put the Flash into Sleep
// Interrupt routines uses in this example:
interrupt void epwm1_timer_isr(void)
{

   // Put the Flash to sleep
   EALLOW;
   FlashRegs.FPWR.bit.PWR = FLASH_SLEEP;
   EDIS;
   
   EPwm1TimerIntCount++;

   // Clear INT flag for this timer
   EPwm1Regs.ETCLR.bit.INT = 1;

   // Acknowledge this interrupt to receive more interrupts from group 3
   PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;
}

//===========================================================================
// No more.
//===========================================================================

